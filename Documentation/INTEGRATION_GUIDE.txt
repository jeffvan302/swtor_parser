/**
 * SWTOR Parser Enhancement Integration Guide
 * ==========================================
 * 
 * This file shows the key changes needed to integrate AreaEntered and 
 * DisciplineChanged support into your existing swtor_parser.cpp
 */

/*
 * STEP 1: Update EventKind enum (in swtor_parser.h)
 * --------------------------------------------------
 * Already done in swtor_parser_enhanced.h - add AreaEntered and DisciplineChanged
 */

/*
 * STEP 2: Update kind_to_cstr function
 * -------------------------------------
 * Add cases for the new event kinds:
 */

const char* kind_to_cstr(EventKind k) {
    switch (k) {
        case EventKind::ApplyEffect: return "ApplyEffect";
        case EventKind::RemoveEffect: return "RemoveEffect";
        case EventKind::Event: return "Event";
        case EventKind::Spend: return "Spend";
        case EventKind::Restore: return "Restore";
        case EventKind::ModifyCharges: return "ModifyCharges";
        case EventKind::AreaEntered: return "AreaEntered";           // NEW
        case EventKind::DisciplineChanged: return "DisciplineChanged"; // NEW
        default: return "Unknown";
    }
}

/*
 * STEP 3: Update parse_combat_line function
 * ------------------------------------------
 * Add detection and parsing for AreaEntered and DisciplineChanged
 * 
 * The key changes are in the event parsing section. Here's the logic:
 */

ParseStatus parse_combat_line(std::string_view line, CombatLine& out) {
    // ... existing parsing code for timestamp, source, target, ability ...
    
    // After parsing the event field, detect special event types:
    
    // Parse event type and effect: [EventType {ID}: Effect {ID}]
    // ... existing code to extract event_text from brackets ...
    
    std::string_view event_text = /* extracted event field */;
    
    // Detect event kind from the event type name
    std::string_view event_type_name = /* extract name before first '{' */;
    EventKind detected_kind = detail::detect_event_kind(event_type_name);
    
    out.evt.kind = detected_kind;
    
    // Handle special event types
    if (detected_kind == EventKind::AreaEntered) {
        // Parse AreaEntered-specific data
        std::string_view value_text = /* extract from (value) field */;
        std::string_view threat_text = /* extract from <threat> field */;
        
        if (!detail::parse_area_entered(event_text, value_text, out.area_entered)) {
            return ParseStatus::Malformed;
        }
        
        // Check if threat field contains version tag
        if (!threat_text.empty() && threat_text.front() == 'v') {
            // This is actually a version tag, not threat
            out.area_entered.version = std::string(threat_text);
        }
        
        // AreaEntered events have empty source and target typically
        // No standard value/threat fields apply
        return ParseStatus::Ok;
        
    } else if (detected_kind == EventKind::DisciplineChanged) {
        // Parse DisciplineChanged-specific data
        if (!detail::parse_discipline_changed(event_text, out.discipline_changed)) {
            return ParseStatus::Malformed;
        }
        
        // DisciplineChanged events have no value or threat fields
        return ParseStatus::Ok;
        
    } else {
        // Normal event processing (existing code)
        // ... parse event ID, effect name/ID, value, threat, etc. ...
    }
    
    // ... rest of existing parsing code ...
    
    return ParseStatus::Ok;
}

/*
 * STEP 4: Parsing Helper - Extract Event Type Name
 * -------------------------------------------------
 * Helper to extract the event type name from the event field
 */

std::string_view extract_event_type_name(std::string_view event_text) {
    // Event format: "EventType {ID}: Effect {ID}"
    // We want just "EventType"
    
    auto brace_pos = event_text.find('{');
    if (brace_pos == std::string_view::npos) {
        return event_text; // Malformed, but return what we have
    }
    
    auto name = event_text.substr(0, brace_pos);
    
    // Trim trailing spaces
    while (!name.empty() && name.back() == ' ') {
        name.remove_suffix(1);
    }
    
    return name;
}

/*
 * STEP 5: Version Tag Parsing
 * ----------------------------
 * AreaEntered lines have a version tag in the "threat" field position.
 * Example: <v7.0.0b>
 * 
 * When parsing the threat field for AreaEntered events, check if it starts
 * with 'v' instead of being a number.
 */

bool parse_threat_or_version(std::string_view text, CombatLine& out) {
    if (text.empty()) return true;
    
    // Remove angle brackets
    if (text.front() == '<') text.remove_prefix(1);
    if (text.back() == '>') text.remove_suffix(1);
    
    if (out.evt.kind == EventKind::AreaEntered) {
        // This is a version tag
        out.area_entered.version = std::string(text);
        return true;
    } else {
        // This is a regular threat value
        out.tail.threat = std::atof(text.data());
        out.tail.has_threat = true;
        return true;
    }
}

/*
 * STEP 6: Update deep_bind_into for Owned Lines
 * ----------------------------------------------
 * When cloning CombatLines, make sure to copy the new fields
 */

void deep_bind_into(CombatLine& dst, const CombatLine& src, detail_json::StringArena& arena) {
    // ... existing field copying ...
    
    // Copy AreaEntered data
    if (src.evt.kind == EventKind::AreaEntered) {
        dst.area_entered.area.name = std::string(
            arena.intern(src.area_entered.area.name)
        );
        dst.area_entered.area.id = src.area_entered.area.id;
        
        if (src.area_entered.has_difficulty) {
            dst.area_entered.difficulty.name = std::string(
                arena.intern(src.area_entered.difficulty.name)
            );
            dst.area_entered.difficulty.id = src.area_entered.difficulty.id;
            dst.area_entered.has_difficulty = true;
        }
        
        dst.area_entered.version = std::string(
            arena.intern(src.area_entered.version)
        );
        dst.area_entered.raw_value = std::string(
            arena.intern(src.area_entered.raw_value)
        );
    }
    
    // Copy DisciplineChanged data
    if (src.evt.kind == EventKind::DisciplineChanged) {
        dst.discipline_changed.combat_class.name = std::string(
            arena.intern(src.discipline_changed.combat_class.name)
        );
        dst.discipline_changed.combat_class.id = src.discipline_changed.combat_class.id;
        
        dst.discipline_changed.discipline.name = std::string(
            arena.intern(src.discipline_changed.discipline.name)
        );
        dst.discipline_changed.discipline.id = src.discipline_changed.discipline.id;
        
        dst.discipline_changed.combat_class_enum = src.discipline_changed.combat_class_enum;
        dst.discipline_changed.discipline_enum = src.discipline_changed.discipline_enum;
    }
}

/*
 * STEP 7: Update JSON serialization (if used)
 * --------------------------------------------
 * Add fields for AreaEntered and DisciplineChanged to to_json()
 */

std::string to_json(const CombatLine& L) {
    // ... existing JSON building ...
    
    // Add special event data
    if (L.evt.kind == EventKind::AreaEntered) {
        // Add: "area_entered": { "area": {...}, "difficulty": {...}, ... }
    } else if (L.evt.kind == EventKind::DisciplineChanged) {
        // Add: "discipline_changed": { "combat_class": {...}, "discipline": {...} }
    }
    
    // ... rest of JSON ...
}

/*
 * STEP 8: Update time_cruncher integration
 * -----------------------------------------
 * The existing isAreaEntered() check in time_cruncher_swtor_windows.cpp
 * should be updated to use the new enum:
 */

bool TimeCruncher::isAreaEntered(const CombatLine& line) const {
    // Old way (checking string):
    // return std::string_view(line.evt.effect.name).find("AreaEntered") != std::string_view::npos;
    
    // New way (checking enum):
    return line.evt.kind == EventKind::AreaEntered;
}

/*
 * USAGE EXAMPLES
 * ==============
 */

// Example 1: Simple detection
void process_log_line(const std::string& raw_line) {
    swtor::CombatLine line;
    if (swtor::parse_combat_line(raw_line, line) == swtor::ParseStatus::Ok) {
        
        // Fast detection using EventPred
        if (line == swtor::Evt::AreaEntered) {
            std::cout << "Entered: " << line.area_entered.area.name << std::endl;
            
            if (line.area_entered.has_difficulty) {
                std::cout << "  Difficulty: " << line.area_entered.difficulty.name << std::endl;
            }
        }
        
        if (line == swtor::Evt::DisciplineChanged) {
            std::cout << "Changed to: " 
                     << combat_class_name(line.discipline_changed.combat_class_enum)
                     << " / "
                     << discipline_name(line.discipline_changed.discipline_enum)
                     << std::endl;
        }
    }
}

// Example 2: Filtering for special events
void find_special_events(const std::vector<swtor::CombatLine>& lines) {
    for (const auto& line : lines) {
        // Using AnyPred to match multiple event types
        if (line == (swtor::Evt::AreaEntered | swtor::Evt::DisciplineChanged)) {
            // Handle special events
        }
    }
}

// Example 3: Switch on event kind
void handle_event(const swtor::CombatLine& line) {
    switch (line.evt.kind) {
        case swtor::EventKind::AreaEntered:
            std::cout << "Area: " << line.area_entered.area.name << std::endl;
            break;
            
        case swtor::EventKind::DisciplineChanged:
            std::cout << "Discipline: " << line.discipline_changed.discipline.name << std::endl;
            break;
            
        case swtor::EventKind::ApplyEffect:
            // Handle damage/heal/buff
            break;
            
        default:
            // Other events
            break;
    }
}

/*
 * TESTING NOTES
 * =============
 * 
 * Test with these example lines:
 * 
 * 1. AreaEntered (simple):
 *    [23:54:32.862] [@Pugonefive#689739618206834|(-5.43,-75.83,39.02,66.32)|(1/183817)] [] [] 
 *    [AreaEntered {836045448953664}: Nar Shaddaa {137438987989}] (he3001) <v7.0.0b>
 * 
 * 2. AreaEntered (with difficulty):
 *    [21:37:53.211] [@Pugzeroeight#688448512393486|(-384.05,169.28,0.17,-91.58)|(421327/437086)] [] [] 
 *    [AreaEntered {836045448953664}: Dxun - The CI-004 Facility {833571547775792} 8 Player Master {836045448953655}] 
 *    (he3001) <v7.0.0b>
 * 
 * 3. DisciplineChanged:
 *    [21:31:26.309] [@Pugzeroeight#688448512393486|(24.16,27.19,9.63,-93.38)|(1/226209)] [] [] 
 *    [DisciplineChanged {836045448953665}: Operative {16140905232405801950}/Lethality {2031339142381593}]
 * 
 * Verify:
 * - line == swtor::Evt::AreaEntered returns true
 * - Area name and ID are parsed correctly
 * - Difficulty is parsed when present
 * - Version tag is captured
 * - Combat class and discipline are parsed correctly
 * - Enum values are set correctly
 */
